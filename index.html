<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PLX vs Crescent Hours Comparison</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useMemo } = React;
        
        // Lucide React icons as inline SVG components
        const Upload = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="17 8 12 3 7 8"></polyline>
                <line x1="12" y1="3" x2="12" y2="15"></line>
            </svg>
        );
        
        const AlertCircle = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="12" y1="8" x2="12" y2="12"></line>
                <line x1="12" y1="16" x2="12.01" y2="16"></line>
            </svg>
        );
        
        const CheckCircle = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                <polyline points="22 4 12 14.01 9 11.01"></polyline>
            </svg>
        );
        
        const Copy = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
            </svg>
        );
        
        const ChevronDown = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <polyline points="6 9 12 15 18 9"></polyline>
            </svg>
        );
        
        const ChevronRight = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <polyline points="9 18 15 12 9 6"></polyline>
            </svg>
        );
        
        const ArrowUpDown = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="m21 16-4 4-4-4"></path>
                <path d="M17 20V4"></path>
                <path d="m3 8 4-4 4 4"></path>
                <path d="M7 4v16"></path>
            </svg>
        );
        
        const Lightbulb = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .2 2.2 1.5 3.5.7.7 1.3 1.5 1.5 2.5"></path>
                <path d="M9 18h6"></path>
                <path d="M10 22h4"></path>
            </svg>
        );

        const PLXCrescentCompare = () => {
          const [plxData, setPlxData] = useState(null);
          const [crescentData, setCrescentData] = useState(null);
          const [editedCrescentRows, setEditedCrescentRows] = useState([]);
          const [editedPlxRows, setEditedPlxRows] = useState([]);
          const [selectedDay, setSelectedDay] = useState('Monday');
          const [selectedShift, setSelectedShift] = useState('1st Shift');
          const [plxFile, setPlxFile] = useState(null);
          const [crescentFile, setCrescentFile] = useState(null);
          const [shift1TotalRow, setShift1TotalRow] = useState(null);
          const [mismatchNotes, setMismatchNotes] = useState({});
          const [crescentErrors, setCrescentErrors] = useState(new Set());
          const [refreshTrigger, setRefreshTrigger] = useState(0);
          const [comparisonCollapsed, setComparisonCollapsed] = useState(true);
          const [crescentCollapsed, setCrescentCollapsed] = useState(true);
          const [plxCollapsed, setPlxCollapsed] = useState(true);
          const [crescentSort, setCrescentSort] = useState({ column: 'EID', direction: 'asc' });
          const [plxSort, setPlxSort] = useState({ column: 'EID', direction: 'asc' });

          // Parse PLX Excel file
          const parsePLXFile = (file) => {
            const reader = new FileReader();
            reader.onload = (e) => {
              try {
                const data = new Uint8Array(e.target.result);
                const workbook = XLSX.read(data, { type: 'array' });
                const sheet = workbook.Sheets[workbook.SheetNames[0]];
                const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });

                const dayRow = jsonData[3] || [];
                const hourTypeRow = jsonData[4] || [];

                const columnMapping = {};
                let currentDay = '';
                
                dayRow.forEach((cell, idx) => {
                  if (cell && typeof cell === 'string' && cell.trim()) {
                    currentDay = cell.trim();
                  }
                  if (currentDay && hourTypeRow[idx]) {
                    const hourType = hourTypeRow[idx].toString().trim();
                    if (hourType.includes('Reg') || hourType.includes('OT') || hourType.includes('DT')) {
                      columnMapping[idx] = { day: currentDay, hourType };
                    }
                  }
                });

                const headerRow = jsonData[4];
                const fileColIdx = headerRow.findIndex(h => h && h.toString().toLowerCase().includes('file'));
                const nameColIdx = headerRow.findIndex(h => h && h.toString().toLowerCase().includes('name'));

                let shift1TotalRowIdx = null;
                for (let i = 5; i < jsonData.length; i++) {
                  const cellValue = jsonData[i][2]?.toString().toLowerCase() || '';
                  if (cellValue.includes('shift') && cellValue.includes('1') && cellValue.includes('total')) {
                    shift1TotalRowIdx = i;
                    break;
                  }
                }
                setShift1TotalRow(shift1TotalRowIdx);

                const records = [];
                for (let i = 5; i < jsonData.length; i++) {
                  const row = jsonData[i];
                  if (!row[fileColIdx]) continue;

                  const fileValue = row[fileColIdx].toString();
                  const eidMatch = fileValue.match(/\d+/);
                  if (!eidMatch) continue;

                  const eid = eidMatch[0];
                  const name = row[nameColIdx] || '';

                  let shift = null;
                  if (shift1TotalRowIdx !== null) {
                    shift = i < shift1TotalRowIdx ? '1st Shift' : '2nd Shift';
                  }

                  records.push({
                    EID: eid,
                    Name: name,
                    row: row,
                    columnMapping: columnMapping,
                    shift: shift,
                    department: row[1]?.toString() || ''
                  });
                }

                setPlxData(records);
              } catch (error) {
                console.error('Error parsing PLX file:', error);
                alert('Error parsing PLX file. Please check the format.');
              }
            };
            reader.readAsArrayBuffer(file);
          };

          // Parse Crescent CSV/Excel file
          const parseCrescentFile = (file) => {
            const reader = new FileReader();
            const fileName = file.name.toLowerCase();
            
            reader.onload = (e) => {
              try {
                let jsonData;
                
                if (fileName.endsWith('.csv')) {
                  const text = e.target.result;
                  const lines = text.split('\n');
                  const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
                  
                  jsonData = lines.slice(1).filter(line => line.trim()).map(line => {
                    const values = line.split(',').map(v => v.trim().replace(/"/g, ''));
                    const obj = {};
                    headers.forEach((header, idx) => {
                      obj[header] = values[idx] || '';
                    });
                    return obj;
                  });
                } else {
                  const data = new Uint8Array(e.target.result);
                  const workbook = XLSX.read(data, { type: 'array' });
                  const sheet = workbook.Sheets[workbook.SheetNames[0]];
                  jsonData = XLSX.utils.sheet_to_json(sheet);
                }

                const aggregated = {};
                jsonData.forEach(row => {
                  const badgeKey = Object.keys(row).find(k => k.toLowerCase() === 'badge');
                  const hoursKey = Object.keys(row).find(k => k.toLowerCase() === 'payable hours');
                  const lineKey = Object.keys(row).find(k => k.toLowerCase() === 'line name');
                  const clockInKey = Object.keys(row).find(k => k.toLowerCase() === 'clock in time');
                  const clockOutKey = Object.keys(row).find(k => k.toLowerCase() === 'clock out time');
                  
                  const badge = badgeKey ? row[badgeKey] : '';
                  const eidMatch = badge.match(/PLX-(\d+)-/i);
                  if (!eidMatch) return;

                  const eid = eidMatch[1];
                  const hours = parseFloat(hoursKey ? row[hoursKey] : 0) || 0;
                  const line = lineKey ? row[lineKey] : '';

                  if (!aggregated[eid]) {
                    aggregated[eid] = {
                      EID: eid,
                      Badges: new Set(),
                      Lines: new Set(),
                      Total_Hours: 0,
                      ClockIn: '',
                      ClockOut: ''
                    };
                  }

                  aggregated[eid].Badges.add(badge);
                  aggregated[eid].Lines.add(line);
                  aggregated[eid].Total_Hours += hours;
                  if (clockInKey && row[clockInKey]) {
                    aggregated[eid].ClockIn = row[clockInKey];
                  }
                  if (clockOutKey && row[clockOutKey]) {
                    aggregated[eid].ClockOut = row[clockOutKey];
                  }
                });

                const records = Object.values(aggregated).map(record => ({
                  EID: record.EID,
                  Badge_Last3: Array.from(record.Badges).map(b => b.slice(-3)).join(', '),
                  FullBadges: Array.from(record.Badges).join(', '),
                  Lines: Array.from(record.Lines).filter(l => l).join(', '),
                  Total_Hours: Math.round(record.Total_Hours * 100) / 100,
                  Direct_Hours: 0,
                  Indirect_Hours: 0,
                  ClockIn: record.ClockIn,
                  ClockOut: record.ClockOut
                }));

                records.forEach(record => {
                  const lines = record.Lines.toLowerCase();
                  if (lines.includes('indirect')) {
                    record.Indirect_Hours = record.Total_Hours;
                  } else {
                    record.Direct_Hours = record.Total_Hours;
                  }
                });

                setCrescentData(records);
                setEditedCrescentRows(records.map(r => ({...r})));
              } catch (error) {
                console.error('Error parsing Crescent file:', error);
                alert('Error parsing Crescent file. Please check the format.');
              }
            };

            if (fileName.endsWith('.csv')) {
              reader.readAsText(file);
            } else {
              reader.readAsArrayBuffer(file);
            }
          };

          // Calculate PLX hours
          const plxProcessed = useMemo(() => {
            if (!plxData) return [];

            const aggregated = {};
            const filteredData = plxData.filter(record => record.shift === selectedShift);
            
            filteredData.forEach(record => {
              let totalHours = 0;
              
              Object.entries(record.columnMapping).forEach(([colIdx, info]) => {
                if (info.day === selectedDay) {
                  const value = parseFloat(record.row[colIdx]) || 0;
                  totalHours += value;
                }
              });

              if (!aggregated[record.EID]) {
                aggregated[record.EID] = {
                  EID: record.EID,
                  Name: record.Name,
                  Total_Hours: 0,
                  Direct_Hours: 0,
                  Indirect_Hours: 0,
                  Department: record.department
                };
              }
              
              aggregated[record.EID].Total_Hours += totalHours;
              
              if (record.department.includes('005-251-221')) {
                aggregated[record.EID].Indirect_Hours += totalHours;
              } else if (record.department.includes('004-251-211')) {
                aggregated[record.EID].Direct_Hours += totalHours;
              }
            });

            const baseRows = Object.values(aggregated)
              .filter(record => record.Total_Hours > 0)
              .map(record => ({
                ...record,
                Total_Hours: Math.round(record.Total_Hours * 100) / 100,
                Direct_Hours: Math.round(record.Direct_Hours * 100) / 100,
                Indirect_Hours: Math.round(record.Indirect_Hours * 100) / 100
              }));

            setEditedPlxRows(baseRows.map(r => ({...r})));
            return baseRows;
          }, [plxData, selectedDay, selectedShift]);

          const plxForComparison = useMemo(() => {
            return editedPlxRows.map(row => ({
              ...row,
              Total_Hours: parseFloat(row.Total_Hours) || 0
            }));
          }, [editedPlxRows, refreshTrigger]);

          const crescentProcessed = useMemo(() => {
            if (editedCrescentRows.length === 0) return [];
            return editedCrescentRows.map(record => ({
              ...record,
              Total_Hours: parseFloat(record.Total_Hours) || 0
            }));
          }, [editedCrescentRows, refreshTrigger]);

          // Comparison
          const compar
