<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PLX vs Crescent Hours Comparison</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useMemo } = React;
        
        // Icon components
        const Upload = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="17 8 12 3 7 8"></polyline>
                <line x1="12" y1="3" x2="12" y2="15"></line>
            </svg>
        );
        
        const AlertCircle = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="12" y1="8" x2="12" y2="12"></line>
                <line x1="12" y1="16" x2="12.01" y2="16"></line>
            </svg>
        );
        
        const CheckCircle = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                <polyline points="22 4 12 14.01 9 11.01"></polyline>
            </svg>
        );
        
        const Copy = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
            </svg>
        );
        
        const ChevronDown = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <polyline points="6 9 12 15 18 9"></polyline>
            </svg>
        );
        
        const ChevronRight = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <polyline points="9 18 15 12 9 6"></polyline>
            </svg>
        );
        
        const ArrowUpDown = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="m21 16-4 4-4-4"></path>
                <path d="M17 20V4"></path>
                <path d="m3 8 4-4 4 4"></path>
                <path d="M7 4v16"></path>
            </svg>
        );
        
        const Lightbulb = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .2 2.2 1.5 3.5.7.7 1.3 1.5 1.5 2.5"></path>
                <path d="M9 18h6"></path>
                <path d="M10 22h4"></path>
            </svg>
        );

        const PLXCrescentCompare = () => {
          const [plxData, setPlxData] = useState(null);
          const [crescentData, setCrescentData] = useState(null);
          const [editedCrescentRows, setEditedCrescentRows] = useState([]);
          const [editedPlxRows, setEditedPlxRows] = useState([]);
          const [selectedDay, setSelectedDay] = useState('Monday');
          const [selectedShift, setSelectedShift] = useState('1st Shift');
          const [plxFile, setPlxFile] = useState(null);
          const [crescentFile, setCrescentFile] = useState(null);
          const [shift1TotalRow, setShift1TotalRow] = useState(null);
          const [mismatchNotes, setMismatchNotes] = useState({});
          const [crescentErrors, setCrescentErrors] = useState(new Set());
          const [refreshTrigger, setRefreshTrigger] = useState(0);
          const [comparisonCollapsed, setComparisonCollapsed] = useState(true);
          const [crescentCollapsed, setCrescentCollapsed] = useState(true);
          const [plxCollapsed, setPlxCollapsed] = useState(true);
          const [crescentSort, setCrescentSort] = useState({ column: 'EID', direction: 'asc' });
          const [plxSort, setPlxSort] = useState({ column: 'EID', direction: 'asc' });

          const parsePLXFile = (file) => {
            const reader = new FileReader();
            reader.onload = (e) => {
              try {
                const data = new Uint8Array(e.target.result);
                const workbook = XLSX.read(data, { type: 'array' });
                const sheet = workbook.Sheets[workbook.SheetNames[0]];
                const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });

                const dayRow = jsonData[3] || [];
                const hourTypeRow = jsonData[4] || [];
                const columnMapping = {};
                let currentDay = '';
                
                dayRow.forEach((cell, idx) => {
                  if (cell && typeof cell === 'string' && cell.trim()) {
                    currentDay = cell.trim();
                  }
                  if (currentDay && hourTypeRow[idx]) {
                    const hourType = hourTypeRow[idx].toString().trim();
                    if (hourType.includes('Reg') || hourType.includes('OT') || hourType.includes('DT')) {
                      columnMapping[idx] = { day: currentDay, hourType };
                    }
                  }
                });

                const headerRow = jsonData[4];
                const fileColIdx = headerRow.findIndex(h => h && h.toString().toLowerCase().includes('file'));
                const nameColIdx = headerRow.findIndex(h => h && h.toString().toLowerCase().includes('name'));

                let shift1TotalRowIdx = null;
                for (let i = 5; i < jsonData.length; i++) {
                  const cellValue = jsonData[i][2]?.toString().toLowerCase() || '';
                  if (cellValue.includes('shift') && cellValue.includes('1') && cellValue.includes('total')) {
                    shift1TotalRowIdx = i;
                    break;
                  }
                }
                setShift1TotalRow(shift1TotalRowIdx);

                const records = [];
                for (let i = 5; i < jsonData.length; i++) {
                  const row = jsonData[i];
                  if (!row[fileColIdx]) continue;

                  const fileValue = row[fileColIdx].toString();
                  const eidMatch = fileValue.match(/\d+/);
                  if (!eidMatch) continue;

                  const eid = eidMatch[0];
                  const name = row[nameColIdx] || '';
                  let shift = null;
                  if (shift1TotalRowIdx !== null) {
                    shift = i < shift1TotalRowIdx ? '1st Shift' : '2nd Shift';
                  }

                  records.push({
                    EID: eid,
                    Name: name,
                    row: row,
                    columnMapping: columnMapping,
                    shift: shift,
                    department: row[1]?.toString() || ''
                  });
                }

                setPlxData(records);
              } catch (error) {
                console.error('Error parsing PLX file:', error);
                alert('Error parsing PLX file. Please check the format.');
              }
            };
            reader.readAsArrayBuffer(file);
          };

          const parseCrescentFile = (file) => {
            const reader = new FileReader();
            const fileName = file.name.toLowerCase();
            
            reader.onload = (e) => {
              try {
                let jsonData;
                
                if (fileName.endsWith('.csv')) {
                  const text = e.target.result;
                  const lines = text.split('\n');
                  const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
                  
                  jsonData = lines.slice(1).filter(line => line.trim()).map(line => {
                    const values = line.split(',').map(v => v.trim().replace(/"/g, ''));
                    const obj = {};
                    headers.forEach((header, idx) => {
                      obj[header] = values[idx] || '';
                    });
                    return obj;
                  });
                } else {
                  const data = new Uint8Array(e.target.result);
                  const workbook = XLSX.read(data, { type: 'array' });
                  const sheet = workbook.Sheets[workbook.SheetNames[0]];
                  jsonData = XLSX.utils.sheet_to_json(sheet);
                }

                const aggregated = {};
                jsonData.forEach(row => {
                  const badgeKey = Object.keys(row).find(k => k.toLowerCase() === 'badge');
                  const hoursKey = Object.keys(row).find(k => k.toLowerCase() === 'payable hours');
                  const lineKey = Object.keys(row).find(k => k.toLowerCase() === 'line name');
                  const clockInKey = Object.keys(row).find(k => k.toLowerCase() === 'clock in time');
                  const clockOutKey = Object.keys(row).find(k => k.toLowerCase() === 'clock out time');
                  
                  const badge = badgeKey ? row[badgeKey] : '';
                  const eidMatch = badge.match(/PLX-(\d+)-/i);
                  if (!eidMatch) return;

                  const eid = eidMatch[1];
                  const hours = parseFloat(hoursKey ? row[hoursKey] : 0) || 0;
                  const line = lineKey ? row[lineKey] : '';

                  if (!aggregated[eid]) {
                    aggregated[eid] = {
                      EID: eid,
                      Badges: new Set(),
                      Lines: new Set(),
                      Total_Hours: 0,
                      ClockIn: '',
                      ClockOut: ''
                    };
                  }

                  aggregated[eid].Badges.add(badge);
                  aggregated[eid].Lines.add(line);
                  aggregated[eid].Total_Hours += hours;
                  if (clockInKey && row[clockInKey]) {
                    aggregated[eid].ClockIn = row[clockInKey];
                  }
                  if (clockOutKey && row[clockOutKey]) {
                    aggregated[eid].ClockOut = row[clockOutKey];
                  }
                });

                const records = Object.values(aggregated).map(record => ({
                  EID: record.EID,
                  Badge_Last3: Array.from(record.Badges).map(b => b.slice(-3)).join(', '),
                  FullBadges: Array.from(record.Badges).join(', '),
                  Lines: Array.from(record.Lines).filter(l => l).join(', '),
                  Total_Hours: Math.round(record.Total_Hours * 100) / 100,
                  Direct_Hours: 0,
                  Indirect_Hours: 0,
                  ClockIn: record.ClockIn,
                  ClockOut: record.ClockOut
                }));

                records.forEach(record => {
                  const lines = record.Lines.toLowerCase();
                  if (lines.includes('indirect')) {
                    record.Indirect_Hours = record.Total_Hours;
                  } else {
                    record.Direct_Hours = record.Total_Hours;
                  }
                });

                setCrescentData(records);
                setEditedCrescentRows(records.map(r => ({...r})));
              } catch (error) {
                console.error('Error parsing Crescent file:', error);
                alert('Error parsing Crescent file. Please check the format.');
              }
            };

            if (fileName.endsWith('.csv')) {
              reader.readAsText(file);
            } else {
              reader.readAsArrayBuffer(file);
            }
          };

          const plxProcessed = useMemo(() => {
            if (!plxData) return [];

            const aggregated = {};
            const filteredData = plxData.filter(record => record.shift === selectedShift);
            
            filteredData.forEach(record => {
              let totalHours = 0;
              
              Object.entries(record.columnMapping).forEach(([colIdx, info]) => {
                if (info.day === selectedDay) {
                  const value = parseFloat(record.row[colIdx]) || 0;
                  totalHours += value;
                }
              });

              if (!aggregated[record.EID]) {
                aggregated[record.EID] = {
                  EID: record.EID,
                  Name: record.Name,
                  Total_Hours: 0,
                  Direct_Hours: 0,
                  Indirect_Hours: 0,
                  Department: record.department
                };
              }
              
              aggregated[record.EID].Total_Hours += totalHours;
              
              if (record.department.includes('005-251-221')) {
                aggregated[record.EID].Indirect_Hours += totalHours;
              } else if (record.department.includes('004-251-211')) {
                aggregated[record.EID].Direct_Hours += totalHours;
              }
            });

            const baseRows = Object.values(aggregated)
              .filter(record => record.Total_Hours > 0)
              .map(record => ({
                ...record,
                Total_Hours: Math.round(record.Total_Hours * 100) / 100,
                Direct_Hours: Math.round(record.Direct_Hours * 100) / 100,
                Indirect_Hours: Math.round(record.Indirect_Hours * 100) / 100
              }));

            setEditedPlxRows(baseRows.map(r => ({...r})));
            return baseRows;
          }, [plxData, selectedDay, selectedShift]);

          const plxForComparison = useMemo(() => {
            return editedPlxRows.map(row => ({
              ...row,
              Total_Hours: parseFloat(row.Total_Hours) || 0
            }));
          }, [editedPlxRows, refreshTrigger]);

          const crescentProcessed = useMemo(() => {
            if (editedCrescentRows.length === 0) return [];
            return editedCrescentRows.map(record => ({
              ...record,
              Total_Hours: parseFloat(record.Total_Hours) || 0
            }));
          }, [editedCrescentRows, refreshTrigger]);

          const comparison = useMemo(() => {
            if (!crescentProcessed.length || !plxForComparison.length) return [];

            const allEIDs = new Set([
              ...crescentProcessed.map(r => r.EID),
              ...plxForComparison.map(r => r.EID)
            ]);

            return Array.from(allEIDs).map(eid => {
              const crescentRecord = crescentProcessed.find(r => r.EID === eid);
              const plxRecord = plxForComparison.find(r => r.EID === eid);

              const crescentHours = crescentRecord?.Total_Hours || 0;
              const plxHours = plxRecord?.Total_Hours || 0;
              const diff = Math.abs(crescentHours - plxHours);

              return {
                EID: eid,
                Name: plxRecord?.Name || '',
                Lines: crescentRecord?.Lines || '',
                FullBadges: crescentRecord?.FullBadges || '',
                Total_Hours_Crescent: crescentHours,
                Total_Hours_PLX: plxHours,
                Status: diff < 0.01 ? 'Match' : 'Mismatch'
              };
            }).sort((a, b) => a.EID.localeCompare(b.EID));
          }, [crescentProcessed, plxForComparison, refreshTrigger]);

          const mismatches = useMemo(() => {
            return comparison.filter(r => r.Status === 'Mismatch');
          }, [comparison]);

          const recommendations = useMemo(() => {
            const recs = [];
            
            mismatches.forEach(mismatch => {
              if (mismatch.Total_Hours_Crescent === 0 || mismatch.Total_Hours_PLX === 0) {
                const crescentBadge = mismatch.FullBadges;
                const crescentEID = mismatch.EID;
                const badgeLetters = crescentBadge.match(/[A-Za-z]{3}$/)?.[0]?.toLowerCase() || '';
                
                plxForComparison.forEach(plxRecord => {
                  const plxLastName = plxRecord.Name.split(' ').pop()?.toLowerCase() || '';
                  const plxEID = plxRecord.EID;
                  
                  if (plxEID === crescentEID) return;
                  
                  if (badgeLetters.length === 3 && plxLastName.includes(badgeLetters)) {
                    recs.push({
                      type: 'Name Match',
                      crescentEID, crescentBadge,
                      crescentHours: mismatch.Total_Hours_Crescent,
                      plxEID, plxName: plxRecord.Name,
                      plxHours: plxRecord.Total_Hours,
                      reason: `Badge letters "${badgeLetters.toUpperCase()}" match last name "${plxLastName.toUpperCase()}"`
                    });
                  }
                  
                  if (crescentEID.length === plxEID.length) {
                    let diffCount = 0;
                    for (let i = 0; i < crescentEID.length; i++) {
                      if (crescentEID[i] !== plxEID[i]) diffCount++;
                    }
                    if (diffCount === 1) {
                      recs.push({
                        type: 'EID Typo',
                        crescentEID, crescentBadge,
                        crescentHours: mismatch.Total_Hours_Crescent,
                        plxEID, plxName: plxRecord.Name,
                        plxHours: plxRecord.Total_Hours,
                        reason: `EID off by 1 digit: ${crescentEID} vs ${plxEID}`
                      });
                    }
                  }
                  
                  if (Math.abs(crescentEID.length - plxEID.length) >= 1) {
                    const shorter = crescentEID.length < plxEID.length ? crescentEID : plxEID;
                    const longer = crescentEID.length > plxEID.length ? crescentEID : plxEID;
                    
                    if (longer.includes(shorter)) {
                      recs.push({
                        type: Math.abs(crescentEID.length - plxEID.length) === 1 ? 'EID Length' : 'Multiple Digits',
                        crescentEID, crescentBadge,
                        crescentHours: mismatch.Total_Hours_Crescent,
                        plxEID, plxName: plxRecord.Name,
                        plxHours: plxRecord.Total_Hours,
                        reason: `Missing ${Math.abs(crescentEID.length - plxEID.length)} digits: ${crescentEID} vs ${plxEID}`
                      });
                    }
                    
                    let matchCount = 0;
                    let j = 0;
                    for (let i = 0; i < longer.length && j < shorter.length; i++) {
                      if (longer[i] === shorter[j]) {
                        matchCount++;
                        j++;
                      }
                    }
                    
                    if (matchCount >= shorter.length - 1 && matchCount >= shorter.length * 0.8) {
                      const alreadyAdded = recs.some(r => 
                        r.crescentEID === crescentEID && r.plxEID === plxEID
                      );
                      if (!alreadyAdded) {
                        recs.push({
                          type: 'Digit Pattern',
                          crescentEID, crescentBadge,
                          crescentHours: mismatch.Total_Hours_Crescent,
                          plxEID, plxName: plxRecord.Name,
                          plxHours: plxRecord.Total_Hours,
                          reason: `Similar digit pattern detected: ${crescentEID} vs ${plxEID}`
                        });
                      }
                    }
                  }
                });
              }
            });
            
            return recs;
          }, [mismatches, plxForComparison]);

          const totalCrescent = useMemo(() => crescentProcessed.reduce((sum, r) => sum + (parseFloat(r.Total_Hours) || 0), 0), [crescentProcessed, refreshTrigger]);
          const totalCrescentDirect = useMemo(() => crescentProcessed.reduce((sum, r) => sum + (parseFloat(r.Direct_Hours) || 0), 0), [crescentProcessed, refreshTrigger]);
          const totalCrescentIndirect = useMemo(() => crescentProcessed.reduce((sum, r) => sum + (parseFloat(r.Indirect_Hours) || 0), 0), [crescentProcessed, refreshTrigger]);
          const totalPLX = useMemo(() => plxForComparison.reduce((sum, r) => sum + (parseFloat(r.Total_Hours) || 0), 0), [plxForComparison, refreshTrigger]);
          const totalPLXDirect = useMemo(() => plxForComparison.reduce((sum, r) => sum + (parseFloat(r.Direct_Hours) || 0), 0), [plxForComparison, refreshTrigger]);
          const totalPLXIndirect = useMemo(() => plxForComparison.reduce((sum, r) => sum + (parseFloat(r.Indirect_Hours) || 0), 0), [plxForComparison, refreshTrigger]);

          const totalDiff = Math.abs(totalCrescent - totalPLX);
          const totalsMatch = totalDiff < 0.01;

          const errorReportText = useMemo(() => {
            const checkedErrors = mismatches.filter(m => crescentErrors.has(m.EID));
            if (checkedErrors.length === 0) return '';

            return checkedErrors.map(row => {
              const badge = row.FullBadges.split(', ')[0] || '';
              return `${row.Name} worked on ${row.Lines} for ${row.Total_Hours_PLX.toFixed(2)} hours (PLX number), not ${row.Total_Hours_Crescent.toFixed(2)} hours (Crescent number) [${badge}]`;
            }).join('\n\n');
          }, [mismatches, crescentErrors]);

          const handleCopyReport = () => {
            navigator.clipboard.writeText(errorReportText);
            alert('Error report copied to clipboard!');
          };

          const handleFixRecommendation = (rec) => {
            const updatedRows = editedCrescentRows.map(row => {
              if (row.EID === rec.crescentEID) {
                return {
                  ...row,
                  EID: rec.plxEID,
                  FullBadges: row.FullBadges.replace(
                    new RegExp(`PLX-${rec.crescentEID}-`, 'i'),
                    `PLX-${rec.plxEID}-`
                  ),
                  Badge_Last3: row.FullBadges.replace(
                    new RegExp(`PLX-${rec.crescentEID}-`, 'i'),
                    `PLX-${rec.plxEID}-`
                  ).slice(-3)
                };
              }
              return row;
            });
            
            setEditedCrescentRows(updatedRows);
            setRefreshTrigger(prev => prev + 1);
          };

          const sortCrescentData = (column) => {
            const direction = crescentSort.column === column && crescentSort.direction === 'asc' ? 'desc' : 'asc';
            setCrescentSort({ column, direction });
            const sorted = [...editedCrescentRows].sort((a, b) => {
              const aVal = column === 'EID' ? a.EID : a.FullBadges;
              const bVal = column === 'EID' ? b.EID : b.FullBadges;
              return direction === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
            });
            setEditedCrescentRows(sorted);
          };

          const sortPlxData = (column) => {
            const direction = plxSort.column === column && plxSort.direction === 'asc' ? 'desc' : 'asc';
            setPlxSort({ column, direction });
            const sorted = [...editedPlxRows].sort((a, b) => {
              const aVal = column === 'EID' ? a.EID : a.Name;
              const bVal = column === 'EID' ? b.EID : b.Name;
              return direction === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
            });
            setEditedPlxRows(sorted);
          };

          return (
            <div className="w-full max-w-[1800px] mx-auto p-6 bg-gradient-to-br from-blue-50 to-indigo-50 min-h-screen">
              <div className="mb-8">
                <h1 className="text-4xl font-bold text-gray-800 mb-2">Labor Hours Comparison Tool</h1>
                <p className="text-gray-600">Compare ProLogistix and Crescent reports to identify discrepancies</p>
              </div>

              <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                <div className="bg-white p-6 rounded-xl shadow-lg border-2 border-transparent hover:border-blue-300 transition-all">
                  <label className="flex items-center justify-center w-full h-36 border-3 border-dashed border-gray-300 rounded-xl cursor-pointer hover:border-blue-500 hover:bg-blue-50 transition-all">
                    <div className="text-center">
                      <Upload className="mx-auto mb-3 text-blue-500" size={40} />
                      <span className="text-sm font-medium text-gray-700">
                        {plxFile ? plxFile.name : 'Upload PLX Report (Excel)'}
                      </span>
                      <p className="text-xs text-gray-500 mt-1">Click to browse</p>
                    </div>
                    <input type="file" className="hidden" accept=".xlsx,.xls" onChange={(e) => { const file = e.target.files[0]; if (file) { setPlxFile(file); parsePLXFile(file); }}} />
                  </label>
                </div>

                <div className="bg-white p-6 rounded-xl shadow-lg border-2 border-transparent hover:border-indigo-300 transition-all">
                  <label className="flex items-center justify-center w-full h-36 border-3 border-dashed border-gray-300 rounded-xl cursor-pointer hover:border-indigo-500 hover:bg-indigo-50 transition-all">
                    <div className="text-center">
                      <Upload className="mx-auto mb-3 text-indigo-
